#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_ray_query : require

#include "common_generated.h"
#include "random_funcs.h"

layout(binding = 0, set = 0) buffer data0 { uint out_color[]; };
layout(binding = 1, set = 0) uniform accelerationStructureEXT m_pAccelStruct;
layout(binding = 2, set = 0) buffer dataUBO { RayTracer_UBO_Data ubo; };
layout(binding = 3, set = 0) buffer Vertices { Vertex vertices[]; };
layout(binding = 4, set = 0) buffer Indices { uint indices[]; };
layout(binding = 5, set = 0) buffer MatIds { uint mat_ids[]; };
layout(binding = 6, set = 0) buffer Materials { MaterialData_pbrMR materials[]; };
layout(binding = 7, set = 0) buffer InstanceMats { mat4 instance_mats[]; };
layout(binding = 8, set = 0) buffer MeshInfos { MeshInfo mesh_infos[]; };
layout(binding = 9, set = 0) uniform texture2D NoiseTexture;
layout(binding = 10, set = 0) uniform sampler NoiseSamp;
layout(binding = 11, set = 0) uniform texture2D gBufferPos;
layout(binding = 12, set = 0) uniform texture2D gBufferNormal;
layout(binding = 13, set = 0) uniform sampler colorSampler;
layout(binding = 14, set = 0) uniform texture2D prevRTImage;
layout(binding = 15, set = 0) uniform sampler prevRTImage_sampler;
layout(binding = 16, set = 0, rgba8) uniform coherent image2D resultImageStatic;
layout(binding = 17, set = 0, rgba8) uniform writeonly image2D resultImageDynamic;
layout(binding = 18, set = 0) uniform texture2D gBufferDepth;
layout(binding = 19, set = 0) uniform sampler prevDepth_sampler;
layout(binding = 20, set = 0) uniform texture2D prevDepth;
layout(binding = 21, set = 0) uniform texture2D gBufferVelocity;
layout(binding = 22, set = 0) uniform texture2D prevNormal;
layout(binding = 23, set = 0) uniform sampler prevColor_sampler;
layout(binding = 24, set = 0, rgba8) uniform writeonly image2D resultImageAO;


uint ColorToInt(vec4 color) 
{
  uvec4 bytes = uvec4(color * 255.0f);
  uint result = (bytes.a << 24) | (bytes.b << 16) | (bytes.g << 8) | (bytes.r);
  return result;
  //return int(color.x * 255 * 0x01000000) + int(color.y * 0x00FF0000) + int(color.z * 0x0000FF00) + int(color.w * 0x000000FF);
}

vec4 ColorToVec4(uint color)
{
  float r = (color & 0xff) / 255.0f;
  float g = ((color & 0xff00) >> 8) / 255.0f;
  float b = ((color & 0xff0000) >> 16) / 255.0f;
  float a = ((color & 0xff000000) >> 24) / 255.0f;
  vec4 result = vec4(r, g, b, a);
  return result;
}

vec3 DecodeNormal(uint a_data)
{
  const uint a_enc_x = (a_data  & 0x0000FFFFu);
  const uint a_enc_y = ((a_data & 0xFFFF0000u) >> 16);
  const float sign   = (a_enc_x & 0x0001u) != 0 ? -1.0f : 1.0f;

  const int usX = int(a_enc_x & 0x0000FFFEu);
  const int usY = int(a_enc_y & 0x0000FFFFu);

  const int sX  = (usX <= 32767) ? usX : usX - 65536;
  const int sY  = (usY <= 32767) ? usY : usY - 65536;

  const float x = sX*(1.0f / 32767.0f);
  const float y = sY*(1.0f / 32767.0f);
  const float z = sign*sqrt(max(1.0f - x*x - y*y, 0.0f));

  return vec3(x, y, z);
}


// RayScene intersection with 'm_pAccelStruct'
//
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(const vec4 rayPos, const vec4 rayDir, const uint cullMask)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, cullMask, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  
  while(rayQueryProceedEXT(rayQuery)) { } // actually may omit 'while' when 'gl_RayFlagsOpaqueEXT' is used
 
  CRT_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {    
	  res.primId    = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	  res.geomId    = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    res.instId    = rayQueryGetIntersectionInstanceIdEXT    (rayQuery, true);
	  res.t         = rayQueryGetIntersectionTEXT(rayQuery, true);
    vec2 bars     = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
    
    res.coords[0] = bars.y;
    res.coords[1] = bars.x;
    res.coords[2] = 1.0f - bars.y - bars.x;
  }

  return res;
}

bool m_pAccelStruct_RayQuery_AnyHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  rayQueryProceedEXT(rayQuery);
  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;
  uint isStaticPass;
  uint isAO;    
} kgenArgs;


vec3 GetNormal(CRT_Hit hit) {
  uint indexOffset = mesh_infos[hit.geomId].indexOffset;
  uint vertexOffset = mesh_infos[hit.geomId].vertexOffset;

  uint i0 = indices[indexOffset + 3 * hit.primId + 0];
  uint i1 = indices[indexOffset + 3 * hit.primId + 1];
  uint i2 = indices[indexOffset + 3 * hit.primId + 2];

  vec4 v0 = vertices[vertexOffset + i0].vertex;
  vec4 v1 = vertices[vertexOffset + i1].vertex;
  vec4 v2 = vertices[vertexOffset + i2].vertex;

  vec4 n0 = vec4(DecodeNormal(floatBitsToInt(v0.w)), 0);
  vec4 n1 = vec4(DecodeNormal(floatBitsToInt(v1.w)), 0);
  vec4 n2 = vec4(DecodeNormal(floatBitsToInt(v2.w)), 0);

  vec3 nLocal = hit.coords[0] * n0.xyz + hit.coords[1] * n1.xyz + hit.coords[2] * n2.xyz;
  vec3 n = normalize(mat3(transpose(inverse(instance_mats[hit.instId]))) * nLocal.xyz);
  return n;
}

vec3 GetPosFromDepth(vec2 screenPos){
  float depth = texture(sampler2D(gBufferDepth, colorSampler), screenPos).x;
  vec4 clipPos = vec4( screenPos * 2.0f - 1.0f, depth, 1.0f);
  vec4 pixelPos = ubo.m_invProjView * clipPos; 
  return (pixelPos.xyz/pixelPos.w);
}

vec3 GetPosFromPrevDepth(vec2 screenPos){
  float depth = texture(sampler2D(prevDepth, prevDepth_sampler), screenPos).x;
  vec4 clipPos = vec4( screenPos * 2.0f - 1.0f, depth, 1.0f);
  vec4 pixelPos = ubo.m_invPrevProjView * clipPos; 
  return (pixelPos.xyz/pixelPos.w);
}

vec2 GetPrevUV(vec4 pos)
{
  vec4 prevScreenPos= (ubo.m_prevProjView) * pos;
  vec3 prevScreenPosNDC = prevScreenPos.xyz/prevScreenPos.w;
  vec2 prevUV = prevScreenPosNDC.xy * 0.5f + vec2(0.5f, 0.5f);
  return prevUV;
}
uint GetDynamic(CRT_Hit hit) {
  return mesh_infos[hit.geomId].dynamicBit;
}


vec4 GetPos(CRT_Hit hit)
{
  uint indexOffset = mesh_infos[hit.geomId].indexOffset;
  uint vertexOffset = mesh_infos[hit.geomId].vertexOffset;

  uint i0 = indices[indexOffset + 3 * hit.primId + 0];
  uint i1 = indices[indexOffset + 3 * hit.primId + 1];
  uint i2 = indices[indexOffset + 3 * hit.primId + 2];

  vec4 p0 = vertices[vertexOffset + i0].vertex;
  vec4 p1 = vertices[vertexOffset + i1].vertex;
  vec4 p2 = vertices[vertexOffset + i2].vertex;

  vec3 p = hit.coords[0] * p0.xyz + hit.coords[1] * p1.xyz + hit.coords[2] * p2.xyz;
  return instance_mats[hit.instId] * vec4(p, 1.0f);
}

vec2 random2(vec2 p) {
    float r1 = texture(sampler2D(NoiseTexture, NoiseSamp), p/64.).x;
    float r2 = texture(sampler2D(NoiseTexture, NoiseSamp), (p + vec2(32))/64.).x;
    return vec2(r1, r2);
}

mat4 GetRotationFromMat4(mat4 matrix) {
  mat4 rotation = matrix;
  rotation[0][3] = 0;
  rotation[1][3] = 0;
  rotation[2][3] = 0;
  rotation[3][3] = 1;
  return rotation;
}

uint MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)
{
    return uint(pixelPosX * uint(1973) + pixelPosY * uint(9277) + frame * uint(26699)) | uint(1);
}

float GetRandomFloat(vec3 random)
{
  vec4 rngState = texture(sampler2D(NoiseTexture, NoiseSamp),random.xy);
    float criteria = (random.z*2) - 1;
    float rngOffset;
    if(criteria > 0)
      rngOffset = rngState.x;
    else
      if(criteria < 0)
        rngOffset = rngState.y;
      else
        rngOffset = rngState.z;
  return rngOffset;
}

float GetRandomFloat1(ivec3 random)
{
  vec2 uv = vec2(random.xy) / 1024.0 + R2(random.z % 1024);
  float value = texture(sampler2D(NoiseTexture, NoiseSamp), uv).x;
  return value;
}
///////////////////////////////////////////////////////////////// subkernels here
void kernel_RayTrace_out_color(uint tidX, uint tidY, uint out_colorOffset) 
{
  uvec2 coordInit = uvec2(gl_GlobalInvocationID[0], gl_GlobalInvocationID[1]);
  ivec2 resCord = ivec2((gl_GlobalInvocationID.x), (gl_GlobalInvocationID.y));
  vec3 color = vec3(0.0f, 0.0f, 0.0f);
  
  uint hash = ((uint(coordInit.x) << 12) | uint(coordInit.y)) ^ floatBitsToUint(ubo.time);
  vec2 screenPos = vec2(tidX, tidY)/1024;
  //CRT_Hit hit = m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir);
  //vec3 hitPoint = texture(sampler2D(gBufferPos, colorSampler), screenPos).xyz;
  vec3 hitPoint = GetPosFromDepth(screenPos);
  vec3 n = texture(sampler2D(gBufferNormal, colorSampler), screenPos).xyz;
  vec3 lightDir = normalize(ubo.lights[0].dir.xyz);
  //debugPrintfEXT("hitPoint %1.2v3f, hitPoint2 %1.2v3f\n", hitPoint, hitPoint2);
  if (kgenArgs.isStaticPass == 1U) // here pass for static objects
  {
    if (ubo.needUpdate.x != 1U)
    {
      vec2 velocityUV = texture(sampler2D(gBufferVelocity, colorSampler), screenPos).xy;
      vec2 prevUV = GetPrevUV(vec4(hitPoint,1.0f));
      //prevUV += velocityUV;
      //need to think about it, do we need it?
      const bool  outOfView = (prevUV.x < 0.00001f || prevUV.x > 0.999999f || prevUV.y < 0.00001f || prevUV.y > 0.99999f);
      if (outOfView)
      {
        imageStore(resultImageStatic, resCord, vec4(0.5f, 0.0f, 0.0f, 1.0));
        return;
      }
      vec3 prevShadow = texture(sampler2D(prevRTImage, prevRTImage_sampler), prevUV).xyz;
      float prevDepth = texture(sampler2D(prevDepth, prevDepth_sampler), prevUV).x;
      float currDepth = texture(sampler2D(gBufferDepth, colorSampler), prevUV).x;
      vec3 currNormal = texture(sampler2D(gBufferNormal, colorSampler), prevUV).xyz;
      vec3 prevNormal = texture(sampler2D(prevNormal, prevColor_sampler), prevUV).xyz;
      
      //add a store for prevNormal
      if (prevShadow.x == 0.0f && prevShadow.z == 1.0f 
        && abs(currDepth - prevDepth) < 0.001)
      {
        imageStore(resultImageStatic, resCord, vec4(prevShadow, 1.0));
        return;
      }
      if ((ubo.needUpdate.y != 1U) &&  prevShadow.x == 1.0f 
        && abs(currDepth - prevDepth) < 0.00001)
      {
        imageStore(resultImageStatic, resCord, vec4(1.0,0.5,1.0f, 1.0));
        return;
      }
    }
  }
  else//here pass for dynamic objects
  {
    if (ubo.needUpdate.x != 1U)
    {
      // vec4 prevColor = imageLoad(resultImageStatic, resCord); 
      // if(prevColor.x == 0.0f && prevColor.z == 1.0f)
      // {
      //   imageStore(resultImageDynamic, resCord, vec4(0.0f,0.0f,0.6f,1.0f));
      //   return;
      // }
      // else // do a reprojection for dynamic
      // {
        //put matrix here, not vehicle postion
        vec4 prevHitPoint = vec4(hitPoint, 1.0f) + ubo.m_invTransMat[3];
        float length1 = length(ubo.m_invTransMat[3]);
        //vec3 jopa = length(ubo.m_vehPos.xyz - prevHitPoint.xyz) * normalize(lightDir);
        // //apply rotation
        vec3 rotPoint = prevHitPoint.xyz - ubo.m_vehPos.xyz;
        prevHitPoint = (vec4(rotPoint,1) * GetRotationFromMat4(ubo.m_invTransMat)) + vec4(ubo.m_vehPos.xyz,0);
        vec3 HitPointProj = lightDir * dot(lightDir,hitPoint.xyz);
        vec3 PrevHitPointProj = lightDir * dot(lightDir,prevHitPoint.xyz);
        int directionOfDepthTrace = dot(HitPointProj,HitPointProj) > dot(PrevHitPointProj,PrevHitPointProj)  ? -1 : 1; //rework to distance between points
        vec3 initPos = prevHitPoint.xyz;
        bool intersectFind = false;
        for (int i = 0; i < depth_steps; i++)
        {
          vec4 tracePos = vec4(initPos + lightDir * directionOfDepthTrace * step_size * i, 1.0f);
          vec3 newPosition = GetPosFromPrevDepth(GetPrevUV(tracePos));
          //debugPrintfEXT("prevHitPoint:%1.5v3f newPosition:%1.5v3f diff:%1.5v3f\n", initPos, newPosition, length(initPos - newPosition));
          //debugPrintfEXT("tracePosDiff %1.2f", length(tracePos.xyz - newPosition));
          if (length(tracePos.xyz - newPosition) < depth_eps)
          {
            prevHitPoint = vec4(newPosition, 1.0f);
            intersectFind = true;
            break;
          }
        }
        vec2 prevUV = GetPrevUV(prevHitPoint);
        vec2 prevUVHitPoint = GetPrevUV(vec4(hitPoint,1.0f));
        //find distance for prevHitPoint
        vec3 prevColor = texture(sampler2D(prevRTImage, prevRTImage_sampler), prevUV).xyz;
        vec3 prevColorHitPoint = texture(sampler2D(prevRTImage, prevRTImage_sampler), prevUVHitPoint).xyz;
        float prevDepthPoint = texture(sampler2D(prevDepth, prevDepth_sampler), prevUV).x;
        float prevDepthHitPoint = texture(sampler2D(prevDepth, prevDepth_sampler), prevUV).x;
        float currDepth = texture(sampler2D(gBufferDepth, colorSampler), prevUV).x;
        vec3 currNormal = texture(sampler2D(gBufferNormal, colorSampler), prevUV).xyz;
        vec3 prevNormal = texture(sampler2D(prevNormal, prevColor_sampler), prevUV).xyz;
        const bool  outOfView = (prevUV.x < 0.00001f || prevUV.x > 0.999999f || prevUV.y < 0.00001f || prevUV.y > 0.99999f);
        float depthDiff = abs(currDepth - prevDepthPoint);
        float dotCurPrev = dot(currNormal, prevNormal);
        if ((prevColor.x == 0.0f) && (prevColor.y == 1.0f) && !outOfView && intersectFind)
        {
          // if (gl_GlobalInvocationID[0]/2 == gl_GlobalInvocationID[1]/2)
          //   debugPrintfEXT("length_left %1.3f, length_right %1.3f\n", length(prevHitPoint.xyz - hitPoint.xyz), (length(ubo.m_invTransMat[3])+point_eps));
          if (length(prevHitPoint.xyz - hitPoint.xyz) < (length1 + point_eps))
            imageStore(resultImageDynamic, resCord, vec4(0.0, 1.0f, 0.0f, 1.0f));
          return;
        }
        if ((ubo.needUpdate.y != 1U) && (prevColorHitPoint.x == 1.0f) && abs(currDepth - prevDepthHitPoint) < 0.0001 && !outOfView)
        {
          imageStore(resultImageDynamic, resCord, vec4(1.0, 1.0f, 0.5f, 1.0f));
          return;
        }
        // else
        // {
        //   // CRT_Hit curr_hit = m_pAccelStruct_RayQuery_NearestHit(vec4(prevHitPoint.xyz, 0.1f), vec4(lightDir, rayMax));
        //   // float prevDist = imageLoad(resultImageDynamic, resCord).z;
        //   // //float currDist = texture(sampler2D(prevDepth, prevDepth_sampler), prevUV).x;
        //   // // float currDepth = texture(sampler2D(gBufferDepth, colorSampler), screenPos).x;
        //   // if (abs(prevDist- curr_hit.t) > 0.01f)
        //   // {
        //   //   vec3 prevColor = texture(sampler2D(prevRTImage, prevRTImage_sampler), prevUV).xyz;
        //   //   //imageStore(resultImageDynamic, resCord, vec4(prevColor, 1.0f));
        //   //   prevColor = vec3(1.0f, 1.0f, 0.0f);
        //   //   imageStore(resultImageDynamic, resCord, vec4(prevColor, 1.0f));
        //   //   return;
        //   // }
        // }
      //}
    }
  }
  

  //vec3 hitPoint_old = vec3(rayPos) + vec3(rayDir)*hit.t;
 
  vec3 lightTangent = normalize(cross(lightDir, vec3(0.0f, 1.0f, 0.0f)));
  vec3 lightBitangent = normalize(cross(lightTangent, lightDir));

  float total = 0.0f;
  uvec3 rnd = uvec3(ubo.randomVal.xyz);
  for (int u = 0; u < samples_cnt; u++)
  {   
    uvec3 hash = pcg3d(uvec3(coordInit, rnd.x));
    float rngOffset = GetRandomFloat1(ivec3(coordInit, hash.x^floatBitsToUint(ubo.time)));
    rnd.x+=u;
    vec2 samplesPos = BlueNoiseInDisk[u];
    vec2 diskPoint = PointOnDisk(ubo.lights[0], rngOffset, samplesPos);
    vec3 shadowDir = normalize(lightDir + diskPoint.x * lightTangent + diskPoint.y * lightBitangent);
    CRT_Hit hitShadow;
    if((kgenArgs.isStaticPass == 1U)) 
     hitShadow = m_pAccelStruct_RayQuery_NearestHit(vec4(hitPoint + shadowDir * 0.15f, 0.0f), vec4(shadowDir, rayMax - 0.15f * 2.0), 1U);
    else
     hitShadow = m_pAccelStruct_RayQuery_NearestHit(vec4(hitPoint + shadowDir * 0.15f, 0.0f), vec4(shadowDir, rayMax - 0.15f * 2.0), (1U << 2));
    color.y = 0.0;
    color.z = 0.0;
    if ((hitShadow.primId != -1))// intersect
    {
      //uint dynamic = GetDynamic(hitShadow);
      total += 1;
      float shade = max(dot(shadowDir, n), 0.1f);
      if((kgenArgs.isStaticPass == 1U))
      {
        color.x += shade;
        color.z = 1.0;
      }
      else if ((kgenArgs.isStaticPass == 0U))
      {
        color.x += shade;
        color.y = 1.0;
      }
    }
  }
  color.x*=(total / (samples_cnt));
  color.x = 1 - color.x;
  //out_color[tidY * ubo.m_width + tidX + out_colorOffset] = ColorToInt(vec4(clamp(color, 0.0, 1.0), 1.0));
  if((kgenArgs.isStaticPass == 1U))
  {
    imageStore(resultImageStatic, resCord, vec4(color, 1.0));
  }
  else
  {
    imageStore(resultImageDynamic, resCord, vec4(color, 1.0));
  }
  
}

void kernel_RayTrace_out_AO(uint tidX, uint tidY, uint out_colorOffset) 
{
  uvec2 coordInit = uvec2(gl_GlobalInvocationID[0], gl_GlobalInvocationID[1]);
  
  vec3 color = vec3(0.0f, 0.0f, 0.0f);
  
  //uint hash = ((uint(coordInit.x) << 12) | uint(coordInit.y)) ^ floatBitsToUint(ubo.time);
  vec2 screenPos = vec2(tidX/1024.0f, tidY/1024.0f);
  vec3 hitPoint = GetPosFromDepth(screenPos);
  vec3 n = texture(sampler2D(gBufferNormal, colorSampler), screenPos).xyz;
  vec3 lightDir = normalize(ubo.lights[0].dir.xyz);
  //HERE DO AO STAFF
  float total = 0.0f;
  ivec3 rnd = ubo.randomVal.xyz;
  for (int u = 0; u < ao_samples_cnt; u++)
  {
    uvec3 hash = pcg3d(uvec3(coordInit, rnd.x));
    float rngOffset = GetRandomFloat1(ivec3(coordInit, hash.x^floatBitsToUint(ubo.time)));
    rnd.x+=u;
    hash = pcg3d(uvec3(coordInit, rnd.y));
    float rngOffset2 = GetRandomFloat1(ivec3(coordInit,(hash.y^floatBitsToUint(ubo.time))));
    rnd.y+=1;

    //debugPrintfEXT("rngOffset %1.4f, rngOffset2 %1.4f rng %v3d\n", rngOffset, rngOffset2, ubo.randomVal.xyz);
    vec3 rndDir = PointOnHemiSphere(rngOffset, rngOffset2);
    //debugPrintfEXT("rndDir %1.4v3f\n", rndDir);
    vec3 AODir = normalize(n + rndDir);
    CRT_Hit hitAO;
    hitAO = m_pAccelStruct_RayQuery_NearestHit(vec4(hitPoint + n * 0.15f, 0.0f), vec4(AODir, rayMax - 0.15f * 2.0), (1U << 2) | 1U);
    color.y = 1.0;
    color.z = 1.0;
    if ((hitAO.t < rayMax))// intersect
    {
      total += 1;
      float shade = min(hitAO.t / rayAOMax, 1.0f);
      color.x += shade;
    }
      
  }
  color.x*=(total / (ao_samples_cnt));
  imageStore(resultImageAO, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));  
}
void kernel_InitEyeRay(uint tidX, uint tidY, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar) 
{
  rayPosAndNear = ubo.m_camPos; // to_float4(m_camPos, 1.0f);
  
  const vec3 rayDir = EyeRayDir(float(tidX), float(tidY), float(ubo.m_width), float(ubo.m_height), ubo.m_invProjView);
  rayDirAndFar  = vec4(rayDir, MAXFLOAT);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tidX = uint(gl_GlobalInvocationID[0]); 
  const uint tidY = uint(gl_GlobalInvocationID[1]); 
  const vec4 m_camPos = ubo.m_camPos;
  const uint m_height = ubo.m_height;
  const uint m_width = ubo.m_width;
  ///////////////////////////////////////////////////////////////// prolog
  if(kgenArgs.isAO == 0U)
  {
    kernel_RayTrace_out_color(tidX, tidY, 0);
  }
  else
  {
    kernel_RayTrace_out_AO(tidX, tidY, 0);
  }
}

